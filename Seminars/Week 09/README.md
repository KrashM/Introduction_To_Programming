<h1>Указатели и референции. Динамична памет</h1>

<h1>1. Референции</h1>

- Референция(псевдоним) е втора променлива която използва същата памет.
- Референцията е задължително да се инциализира при декларация!

```c++
int x = 10;
int &y = x;

y++; // Променя х и у
x++; // Променя х и у
```

<h1>2. Указател</h1>

- Указател е променлива, в която пазим адрес(шеснайсетично число) от паметта.
- Указателят не е задължително да се инициализира при декларация.
- Указателят може да променя стойността си(да сочи към друг адрес).
- Големината на указателя в паметта зависи от операционната система, която използваме - 4 bytes (32-bit) / 8 bytes (64-bit).

```c++
int x = 10;
int *ptr = &x;

// 0x61fe14 -> Адрес в паметта(там се пази информацията на x)
std::cout << ptr;
```

Пример за употреба на указател:

```c++
int arr[] = {1, 2, 3};
int* ptr = arr;
```

![](https://i.ibb.co/cDcX8st/Untitled-Diagram-drawio-3.png)

```c++
ptr++;
std::cout << ptr[0]; //2;
std::cout << ptr[1]; //3;
```

![](https://i.ibb.co/xLLsVK5/Untitled-Diagram-drawio-4.png)

<h1>3. Важни оператори</h1>

<h3>3.1. Оператор &</h3>

- Приема променлива от тип Т.
- Връша указател от тип Т*.

```c++
int x = 10;
int *ptr = &x;
```

<h3>3.2. Оператор *</h3>

- Приема указател от тип Т*.
- Връща променлива от тип Т.

```c++
int x = 10;
int *ptr = &x;
// result вече живее в друг адрес в паметта и няма нищо общо с x.
int result = *ptr;
std::cout << result;
```

<h1>4. Важни разлики</h1>

- Указателят може да се "re-assign"-ва. Може да приема нови стойност.
- Референцията трябва да се инициализира при създаването.
- Указателят има неутрална стойност (nullptr), а референцията няма.
- Може да се направи масив от указатели, но не и масив от референции.

<h1>5. Видове памет</h1>

![](https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg)

<h1>6. Динамична памет</h1>

<h3>6.1. Stack</h3>

- Паметта, която ще се задели, се определя по време на **компилация**.
- Паметта се освобождава автоматично - при излизането от scope-а,  в който е дефинирана.

<h3>6.2. Heap</h3>

- От тук се заделя памет по време на **изпълнение** на програмата.
- Масиви и обекти без предварително да е известна големината.
- Паметта продължава да е "заета" дори и след излизане от scope-а.

<h3>6.3. Оператор new</h3>

- Връща указтел към началото на паметта, която сме заделили.
- Заделянето на динамична памет е много "**бавна**" операция!!

**!!Важно!!** При заделяне на памет с оператора new паметта се маркира като използвана. И остава така дори след приключване на програмата! Това се нарича **memory leak**.

```c++
// Memory on the stack:
// 8 bytes for 64-bit
// 4 bytes for 32-bit
// Memory on the heap:
// 4 bytes for the integer
int *ptr = new int;

// Memory on the stack:
// 8 bytes for 64-bit
// 4 bytes for 32-bit
// Memory on the heap:
// 10 * 4 for the integers
int *ptrArray = new int[10];
```

<h3>6.4 std::nothrow</h3>

- Оператор new може да хвърли грешка при опит да заделим памет.
- std::nothrow е инструмент, с който можем да избегнем потенциални memory leak-ове.

```c++
int *ptr = new int;

// Тук програмата ще хвърли грешка, защото не може да задели толкова памет.
// Съответно ptr ще leak-не и имаме проблем.
int *temp = new int[10'000'000'000];

delete ptr;
```

Начинът да се справим с този проблем е следният:
```c++
int *ptr = new(std::nothrow) int;
if(ptr == nullptr)
{
    std::cout << "Memory error\n";
    return -1;
}

// Тук програмата ще хвърли грешка, защото не може да задели толкова памет.
// Съответно ptr ще leak-не и имаме проблем.
int *temp = new(std::nothrow) int[10'000'000'000];
if(!temp)
{
    std::cout << "Memory error\n";
    // Освобождаваме паметта, която в противен случай е щяла да leak-не.
    delete ptr;
    return -1;
}

delete ptr;
```

<h3>6.5. Оператор delete</h3>

- Динамична памет **НЕ** се трие автоматично, както в други езици.
- Оператор delete и delete[] - освобождава динамична памет!

```c++
int *ptr = new int(10);
int *ptrArray = new int[10];

delete ptr; // Използваме за единични указатели
delete[] ptrArray; // Използва се за масиви от указатели
```

<h1>7. Примери за лоша употреба на динамична памет</h1>

```c++
void f()
{
    int x = 10;
    bool used[5] = { true, false };
    int *ptrArray = new int[4];
}
```

След приключването на функцията ще се изчисти паметта в стека, но **Не** и паметта в heap-а.

Ние ръчно трябва да я маркираме като свободна.

```c++
void f()
{
    int x = 10;
    bool used[5] = { true, false };
    int *ptrArray = new int[4];
    delete[] ptrArray;
}
```

<h1>Задачи</h1>

**Задача 1** Да се напише програма, която при въведен масив от n цели числа да намира кой от всички елементи преобладава. Ако има еднакъв брой преобладаващи числа да се извади първото срещнато.

*Вход: n = 7, array = [2, 2, 1, 1, 1, 2, 2]*</br>
*Изход: 2*

*Вход: n = 3, array = [3, 2, 3]*</br>
*Изход: 3*

**Задача 2** Да се напише програма, която при въведени масив от n цели числа и ги сортира в нарастващ ред спрямо броя на включените им битове. Ако има 2 числа с еднакъв брой включени битове да се подредят в нарастващ ред.

*Вход: n = 9, array = [0 1 2 3 4 5 6 7 8]*</br>
*Изход: 0 1 2 4 8 3 5 6 7*

Обяснение:</br>
[0] - 0 включени бита.</br>
[1,2,4,8] - 1 включен бит.</br>
[3,5,6] - 2 включени бита.</br>
[7] - 3 включени бита.

*Вход: n = 10, array = [1024 512 256 128 64 32 16 8 4 2 1]*</br>
*Изход: 1 2 4 8 16 32 64 128 256 512 1024*

**Задача 3** Напишете функция, която при подаден масив с дължина n и n цели числа, намира най-малкият ***среден индекс***. Ако не съществува ***среден индекс***, който да удовлетворява условията върнете -1. ***Среден индекс*** е индекс, за който е в сила следните зависимости:

- nums[0] + nums[1] + ... + nums[middleIndex - 1] == nums[middleIndex + 1] + nums[middleIndex + 2] + ... + nums[n - 1]
- Ако ***средният индекс*** е 0, то лявата сума се счита за 0.
- Ако ***средният индекс*** е n - 1, то дясната сума се счита за 0.

*Вход: n = 5, nums = [2 3 -1 8 4]*</br>
*Изход: 3*

*Вход: n = 3, nums = [1 -1 4]*</br>
*Изход: 2*

*Вход: n = 2, nums = [2 5]*</br>
*Изход: -1*

**Задача 4** Да се напише функция, която приема n x m матрица от цели положителни числа acoounts, където accounts[i][j] е сумата, която i-тия човек държи, в банка j. Функцията да връща кой е най-богатият човек. Състоянието на един човек се определя от сбора на сумите, които той държи във всички банки.

*Вход: n = 2, m = 3, accounts = [[1 2 3], [3 2 1]]*</br>
*Изход: 6*

*Вход: n = 3, m = 2, accounts = [[1 5], [7 3], [3 5]]*</br>
*Изход: 10*

*Вход: n = 3, m = 3, accounts = [[2 8 7], [7 1 3], [1 9 5]]*</br>
*Изход: 17*

**Задача 5** Да се напише функция, която при подаден масив с дължина 2*n, намира дали масивът може да се раздели на n двойки, за които са изпълнени следните условия:

- Всеки елемент от масива може да участва само в една двойка.
- Числата във всяка двойка да са равни.

Функцията да връща true ако такова разпределение е възможно и false в противен случай.

*Вход: n = 6, array = [3 2 3 2 2 2]*</br>
*Изход: true*

*Вход: n = 4, array = [1 2 3 4]*</br>
*Изход: true*

**Задача 6** Да се напише функция, която при подаден масив от n цели числа, връща нов масив от вида: answer[i] = |leftSum[i] - rightSum[i]|.

- Размерът на answer е същият като на оригиналният масив.
- leftSum[i] е сумата на числата в интервала [0, i). Ако i = 0, считаме сумата за 0.
- rightSum[i] е сумата на числата в интервала (i, n - 1]. Ако i = n - 1, считаме сумата за 0.

*Вход: n = 4, array = [10 4 8 3]*</br>
*Изход: [15 1 11 22]*

*Вход: n = 1, array = [1]*</br>
*Изход: [0]*

**Задача 7** Напишете функция, която при подаден масив от цели числа с дължина n и цяло число k, което е елемент от масива, да пренареди елементите в масива, така че всички по-малки елемнти от k да са отляво на k, а всички по-големи да са отдясно на него.

*Вход: 9 [1 5 6 3 0 -1 2 9 7] 3*</br>
*Изход: [1 0 -1 2 3 6 5 9 7]*
<h1>Рекурсия</h1>

<h1>1. Разпределение на паметта</h1>

- Stack - статична памет. Големината не се променя ~ 2MB
- Heap - динамична памет. Големината се променя ~ RAM size
- Global variables - променливи инциализирани с 0. Големината не се променя ~ 8KB
- Initialized data & text - инициализираните променливи и нашият код. Големината се определя при стартиране на програмата.

![](https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg)

<h1>2. Какво означава това за няшият код</h1>

- Stack
    - Променливи - int, bool, char, int*...
    - Масиви - int arr[255], char str[16]...
    - Извиквания на функции - void f(), void printArray(int *array, int size)

- Heap
    - Динамично заделени блокове от памет(operator new).

<h1>3. Рекурсивни функции</h1>

- Защо имаме нужда от рекурсията?
Краткият отговор е, че това е много полезна техника за нашия арсенал, с която можем драстично да намалим кода, който пишем.
<br>
- Пример за рекурсивна функция

```c++
void f()
{
    cout << "Hello\n";
    f();
}
```

- Тази функция ще запълни Stack-а с извиквания => Stack overflow грешка.
- За тази цел ни трябва терминиращо условие(дъно на рекурсията):

```c++
void f(unsigned int n)
{
    if(n == 0) return; // Дъно на рекурсията
    cout << "Hello\n";
    f(n - 1);
}
```

<h1>4. Видове рекурсия</h1>

- Директна:

```c++
void f()
{
    f();
}
```

Функцията извиква сама себе си.

- Индиректна:

```c++
void g();

void f()
{
    g();
}

void g()
{
    f();
}
```

Функцията извиква друга функцията, която се връща в първоначалната.

- Линейна: факториел, сума на числа, степенуване<br>
![](http://www.herevego.com/wp-content/uploads/2020/08/recur.gif)
- Експоненциална/Дървовидна: редицата на фибуначи<br>
![](https://i.stack.imgur.com/ICG4L.png)

<h1>5. Рекурсия vs Итерация</h1>

|№|                 Рекурсия                  |                 Итерация                |
|-|-------------------------------------------|-----------------------------------------|
|1|Приключва, когато базовото условие е вярно.|Приключва, когато условието стане грешно.|
|2|Използва се с функции.                     |Използва се с циклични оператори.        |
|3|Изисква допълнително памет на Stack-а.     |Не изисква допълнително памет.           |
|4|Много по-малко код.                        |Много повече код.                        |

<h1>Задачи</h1>

**Задача 1** Да се направи рекурсивна функция, която намира първата главна буква в низ. Ако низът няма главна буква да се връща '\0'. (Може да използвате и pointer arithmetic)

*Вход: my name is Gosho Изход: G*</br>
*Вход: my name is gosho Изход:*

**Задача 2** Да се направи рекурсивна функция, която принтира пирамида от числа.

*Вход: 4*</br>
*Изход:*</br>
*1*</br>
*2 3*</br>
*4 5 6*</br>
*7 8 9 10*

**Задача 3** Да се напише рекурсивна функция, която приема масив и събира всеки две съседни числа, докато не получи 1 число.

*Вход: [1, 2, 3, 4, 5] Изход: 48*</br>
Поянснение:</br>
[1, 2, 3, 4, 5]</br>
[1 + 2, 2 + 3, 3 + 4, 4 + 5] => [3, 5, 7, 9]</br>
[3 + 5, 5 + 7, 7 + 9] => [8, 12, 16]</br>
[8 + 12, 12 + 16] => [20, 28]</br>
[20 + 28] => 48

**Задача 4** Да се напише рекурсивна функция, която принтира всички числа с 1 до n бита, които нямат последователни 1ци.

*Вход: 4 Изход: 1 2 4 5 8 9 10*
<h1>Полезни алгоритми и функции</h1>

<h3>1. Time complexity</h3>

Времевата сложност е изчислителната сложност, която описва количеството компютърно време, необходимо за изпълнение на алгоритъм. Времевата сложност обикновено се оценява чрез преброяване на елементарните операции, извършени от алгоритъма.

Има 3 вида оценки на алгоритми best case, average case и worst case. Като най-използваната от тях е worst case.

Сложността най-често се изразява с помощта на "big O" нотацията.

Примери:</br>
O(1) - Константно</br>
O(logn) - Логаритмично</br>
O(n) - Линейно</br>
O($n^2$) - Квадратично

### 2. Bubble sort - O($n^2$)

```c++
const size_t SIZE = 10;
int arr[SIZE] = { 5, 1, 6, 8, 0, 4, 3, 2, 9, 7 };
bool swapped;

// Извъртаме всички елементи без последния тъй като сравняваме с i + 1.
for(size_t i = 0; i < SIZE - 1; i++){
    swapped = false;
    // Въртим от 0 тъй като елементите от SIZE - 1 до SIZE - i - 1 са сортирани
    // и търсим какво да разменим с i-тия.
    for(size_t j = 0; j < SIZE - i - 1; j++)
        // Ако j-тия елемент е по-голям от j+1-вия ги разменяме.
        // Със знака > сортираме в нарастващ ред.
        // Със знака < сортираме в намаляващ ред.
        if(arr[j] > arr[j + 1]){

            swap(arr[j], arr[j + 1]);
            swapped = true;

        }

    // Ако не се сменят нито една двойка съседни клетки, то масивът е сортиран.
    if(!swapped) break;
}
```

### 3. Insertion sort - O($n^2$)

```c++
const size_t SIZE = 10;
int arr[SIZE] = { 5, 1, 6, 8, 0, 4, 3, 2, 9, 7 };

// Въртим от 1-вия до последния елемент на масива.
for(size_t i = 1; i < SIZE; ++i){

    size_t j = i - 1;
    // Запазваме копие на i-тия елемент.
    int x = array[i];

    // Въртим от i-тия елемент до първия или докато не намерим елемент, който е по-голям от i-тия.
    while(j >= 0 && array[j] > x){

        // На всяка итерация изместваме елементите с един надясно.
        array[j + 1] = array[j];
        --j;

    }

    // "Вмъкваме" елементът на позиция j+1 (слагаме я на нейното сортирано място).
    array[j + 1] = x;

}
```

### 4. Selection sort - O($n^2$)

```c++
const size_t SIZE = 10;
int arr[SIZE] = { 5, 1, 6, 8, 0, 4, 3, 2, 9, 7 };

// Извъртаме всички елементи без последния тъй като сравняваме с i + 1.
for(size_t i = 0; i < SIZE - 1; i++){
    // Тук ще пазим индексът на минималният елемент в остатъка на масива.
    size_t min_index = i;
    // Въртим от i + 1 тъй като елементите от 0 до i - 1 са сортирани
    // и търсим какво да разменим с i-тия.
    for(size_t j = i + 1; j < SIZE; j++){
        // Ако i-тия елемент е по-малък от j-тия ги разменяме.
        // Със знака > сортираме в нарастващ ред.
        // Със знака < сортираме в намаляващ ред.
        if(arr[min_index] > arr[j]){
            min_index = j;
        }
    }
    // Разменяме минималният елемент с текущият, ако им по-малък от текущият.
    if(min_index != i){
        swap(arr[i], arr[j]);
    }
}
```

### 5. Binary search - O(log(n))

**!Важно!** За този алгоритъм ни е **необходим** сортиран масив.

```c++
const size_t SIZE = 10;
int arr[SIZE] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

int start = 0, end = SIZE - 1, mid, toBeSearched = 2; // Ще търсим 2 във сортирания масив

while(start <= end){

    // Намираме средата.
    mid = (start + end) / 2;

    // Намерили сме елемента който търсим.
    if(arr[mid] == toBeSearched){

        std::cout << "Found\n";
        break;

    }

    // Търсения елемент е по-малък от средния.
    // Продължаваме да търсим в лявата половина.
    if(toBeSearched < arr[mid]) end = mid - 1;
    // Търсения елемент е по-голям от средния.
    // Продължаваме да търсим в дясната половина.
    else start = mid + 1;

}
```

<h1>Задачи</h1>

**Задача 1:** Да се напише програма, в която се въвежда цяло положително число n и след това n на брой цели числа (елементи на масив). След което програмата да въвежда едно цяло положително число k. Да се напише функция, която да намери най-големия елемент, по-малък или равен на k. Ако няма такъв елемент в масива, функцията да върне INT32_MIN. *За вход приемаме, че въведените масиви ще са сортирани*. **Функцията трябва да работи със сложност по време O(log(n)) и сложност по памет O(1)**.

*Вход:*</br>
*5*</br>
*1 2 3 4 5*</br>
*4*</br>
*Изход: 4*

*Вход:*</br>
*5*</br>
*1 3 5 10 41*</br>
*12*</br>
*Изход: 10*

*Вход:*</br>
*5*</br>
*1 2 3 4 5*</br>
*0*</br>
*Изход: -2147483648*

**Задача 2:** Да се напише програма, в която се въвежда цяло положително число n и след това n на брой уникални цели числа (елементи на масив) в интервала [0, n]. Да се напише функция, която намира кой е елементът, който липсва.

*Вход:*</br>
*3*</br>
*3 0 1*</br>
*Изход: 2*

*Вход:*</br>
*2*</br>
*0 1*
*Изход: 2*

*Вход:*</br>
*9*</br>
*9 6 4 2 3 5 7 0 1*
*Изход: 8*

**Можете ли да се сетите за решение със сложност по време O(n) и сложност по памет O(1)?**

**Задача 3:** Да се напише програма, в която се въвежда цяло положително число n и след това n на брой цели числа (елементи на масив). След което програмата да въвежда едно цяло положително число k. Да се напише функция, която принтира всички индекси на които arr[index] == k, след като сортирате масива. **Функцията трябва да работи със сложност по време O($n^2$) и сложност по памет O(1)**.

*Вход:*</br>
*5*</br>
*1 2 5 2 3*</br>
*2*</br>
*Изход: 1 2*

*Вход:*</br>
*5*</br>
*1 2 5 2 3*</br>
*3*</br>
*Изход: 3*

*Вход:*</br>
*5*</br>
*1 2 5 2 3*</br>
*5*</br>
*Изход: 4*

**Задача 4:** Да се напише програма, в която се въвежда цяло положително число n, което е >= 3 и след това n на брой цели числа (елементи на масив). Масивът ще има видът на планина. Това означава, че за някое i важи следното твърдение:

- arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
- arr[i] > arr[i + 1] > ... > arr[n - 1]

Напишете функция, която по подадени arr и n, намира този индекс i. **Тази функция трябва да работи със сложност по време O(log(n)) и сложност по памет O(1)**.

*Вход:*</br>
*3*</br>
*0 1 0*</br>
*Изход: 1*

*Вход:*</br>
*4*</br>
*0 2 1 0*</br>
*Изход: 1*

*Вход:*</br>
*3*</br>
*0 5 10 2*</br>
*Изход: 2*

**Задача 5:** Да се напише програма, в която се въвежда цяло положително число n и след това n на брой цели числа в интервала [0, n - 1] (елементи на масив). Да се напише функция, която намира, кой от елементите в този масив се повтаря. **Функцията трябва да работи със сложност по време O(n) и сложност по памет O(1)**.

*Вход:*</br>
*5*</br>
*1 3 4 2 2*</br>
*Изход: 2*

*Вход:*</br>
*5*</br>
*3 1 3 4 2*</br>
*Изход: 3*

**Задача 6:** Да се напише програма, в която се въвежда цяло положително четно число n и след това n на брой цели числа (елементи на масив). Напишете функция, която групира елементите на масива по двойки: ($a_1$, $b_1$), ($a_2$, $b_2$), ..., ($a_n$, $b_n$), така че сумата на min($a_i$, $b_i$) за всяко i да е максимална. Функцията да връща максималната сума. **Функцията трябва да работи със сложност по време O($n^2$) и сложност по памет O(1)**.

*Вход:*</br>
*4*</br>
*1 4 3 2*</br>
*Изход: 4*

*Вход:*</br>
*6*</br>
*6 2 6 5 1 2*</br>
*Изход: 9*

**Задача 7:** Да се напише програма, в която се въвежда цяло положително число n и след това n на брой цели числа (елементи на масив). След което програмата да въвежда едно цяло число k. Напишете функция, която намира броя на всички двойки числа в масива (arr[i], arr[j]) имат сбор < k, където 0 <= i < j < n. **Функцията трябва да работи със сложност по време O($n^2$) и сложност по памет O(1)**.

*Вход:*</br>
*5*</br>
*-1 1 2 3 1*</br>
*2*</br>
*Изход: 3*

*Вход:*</br>
*7*</br>
*-6 2 5 -2 -7 -1 3*</br>
*-2*</br>
*Изход: 10*
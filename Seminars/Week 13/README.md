<h1>Указатели към функции и функции от по-висок ред.</h1>

<h3>1. Пример за работа без указатели към функции</h3>

Ако ни дадат за задача да напишем функция, която обикаля масив и прилага дадена функция върху всеки един от елементите му. То това би изглеждало така:

```c++
int AddOne(const int x)
{
    return x + 1;
}

void Map(int * const array, const size_t size)
{
    for(size_t i = 0; i < size; ++i)
    {
        array[i] = AddOne(array[i]);
    }
}
```

Сега идва въпроса, ами какво става ако искам да направя същото нещо, обаче функцията, която ще променя елементите да прави друго нещо. Звучи лесно просто ще добавим още 2 функции за това.

```c++
int AddOne(const int x)
{
    return x + 1;
}

int Double(const int x)
{
    return 2 * x;
}

void MapWithAddOne(int * const array, const size_t size)
{
    for(size_t i = 0; i < size; ++i)
    {
        array[i] = AddOne(array[i]);
    }
}

void MapWithDouble(int * const array, const size_t size)
{
    for(size_t i = 0; i < size; ++i)
    {
        array[i] = Double(array[i]);
    }
}
```

Ами ако реша да добавя още 10 такива операции?

<h3>2. Указатели към функции</h3>

Тук би било редно да въведем първо, какво е указател към функция, преди да отговорим на въпросът по-горе.

- Указател към функция е както всички останали указатели. Той сочи към адрес в паметта.
- Разликата при този вид указател е, че не сочим към клетка с данни, ами към клетка с инструкции.
- Нашата програма се компилира до изпълним файл, в който инструкциите за всяка една функция живеят на някой адрес в паметта.

<h5>2.1 Синтаксис</h5>

```c++
void Print(int x)
{
    std::cout << "Hello World! Value is: " << x << '\n';
}

int main()
{
    void(*function)(int);

    function = &Print;
    function = Print;

    return 0;
}
```

Няколко неща, които е важно да се отбележат:

- Макар и страшният си вид, указателите към функции са както всички останали променливи. Имат си тип, име и можем да им присвояваме стойност.
- Типът на горепосоченият пример е следният: void(*)(), името на променливата е function, а стойностите, които присвояваме са &Print и Print.
- Защо можем да правим &Print и Print? Защото както знаем операторът & ни дава адреса на променлива или в случая на функция. Вторият вариант е по-модерен начин, който c++ позволява като синтаксис.
- Типът на функцията означава следното нещо:
    - void - Функцията, която ще присвоим ще връща void.
    - (*variable_name) - указва, че това е указател към функция
    - (int) - в тези скоби се отбелязва типът на променливите, които ще се подадат на присвоената функция като аргументи.

<h5>2.2 Употреба</h5>

Направили сме указател към функция. Сега въпросът е как да го използваме?

```c++
void Print(int x)
{
    std::cout << "Hello World! Value is: " << x << '\n';
}

int main()
{
    void(*function)(int) = Print;

    function(3);
    function(2);
    function(6);

    return 0;
}
```

Можем да извикваме променливата, както нормална функция и тя ще работи, както бихме очаквали.

<h3>3. Функции от по-висок ред</h3>

Сега с новопридобитите ни знания можем да се върнем на първоначалният въпрос. А именно, какво трябва да направим, ако искаме да имаме 10 различни функции за една и съща операция? Отговорът на този въпрос са функциите от по-висок ред.

`Функция от по-висок ред е функция, която приема функция като аргумент.`

```c++
int AddOne(const int x)
{
    return x + 1;
}

int Double(const int x)
{
    return 2 * x;
}

void Map(int * const array, const size_t size, int(*operation)(const int))
{
    for(size_t i = 0; i < size; ++i)
    {
        array[i] = operation(array[i]);
    }
}
```

По този начин, ако реша да добавя още операции, единственото, което трябва да променя е начинът, по който извиквам функцията Map.

Ето и финалният вариант на нашата програма.

```c++
int AddOne(const int x)
{
    return x + 1;
}

int Double(const int x)
{
    return 2 * x;
}

void Map(int * const array, const size_t size, int(*operation)(const int))
{
    for(size_t i = 0; i < size; ++i)
    {
        array[i] = operation(array[i]);
    }
}

int main()
{
    const size_t SIZE = 5;
    int array[SIZE] = {1, 2, 3, 4, 5};

    Map(array, SIZE, AddOne);

    for(size_t i = 0; i < SIZE; ++i)
    {
        std::cout << array[i] << ' ';
    }
    std::cout << '\n';

    Map(array, SIZE, Double);

    for(size_t i = 0; i < SIZE; ++i)
    {
        std::cout << array[i] << ' ';
    }
    std::cout << '\n';

    return 0;
}
```

<h3>4. Функции, които връщат функции, като резултат</h3>

```c++
void HelloWorld()
{
    std::cout << "Hello World!\n";
}

void HelloThere()
{
    std::cout << "Hello There!\n";
}

void (*PrintFactory(const bool flag))()
{
    if(flag)
    {
        return HelloWorld;
    }
    return HelloThere;
}

int main()
{
    PrintFactory(true)();
    PrintFactory(false)();

    return 0;
}
```

<h3>5. typedef и как ни помага</h3>

За писане на по-дълги или сложни типове, не е добра идея да бъдат изписвани всеки път. За тази цел имаме typedef. Той ни позволява да си дефинираме синоним на типът, който искаме да използваме.

```c++
typedef int** IntMatrix;

int main()
{
    IntMatrix matrix;
    return 0;
}
```

```c++
typedef void(*PrintFunction)();

void HelloWorld()
{
    std::cout << "Hello World!\n";
}

void HelloThere()
{
    std::cout << "Hello There!\n";
}

PrintFunction PrintFactory(const bool flag)
{
    if(flag)
    {
        return HelloWorld;
    }
    return HelloThere;
}

int main()
{
    PrintFunction func = PrintFactory(true);
    func();
    func = PrintFactory(false);
    func();
    return 0;
}
```

<h1>Задачи</h1>

**Задача 1** Да се реализира рекурсивен вариант на функцията Map.

**Задача 2** Да се реализира функция Filter, която при подаден масив от елемнти, размер на масива и фунция предикат, да филтрира елемнтите на масива, които отговарят на предиката и да върне нов масив с **точна големина**, който да съдържа само филтрираните елементи.

*Пример:*
*[1, 2, 3, 4, 5]*
*Предикатна функция: f(x) -> true, ако x е четно; false, ако x е нечетно.*

*Изход:*
*2 4*

**Задача 3** Да се напише сортираща функция, която взима като аргумент предикатна функция и я използва като критерии за сортирането. Демонстрирайте работата на програмата с следните предикати:

- Четен елемент е преди нечетен
- Прости числа преди всички останали

**Задача 4** Да се реализира рекурсивната функция foldl със следните параметри:

- акумулираща променлива, в която да се пази резултатът
- масив от цели числа
- размер на масива
- функция, която да се приложи върху акумулиращата променлива и всички елемнти на масива

Пример, за това как трябва да работи функцията.

foldl(0, [1, 2, 3, 4, 5], 5, add) -> foldl(1, [2, 3, 4, 5], 4, add) -> ... -> foldl(10, [5], 1, add) -> foldl(15, [], 0, add)

Резултатът, който искаме да получим накрая се намира в акумулиращата променлива, съответно искаме да върнем нея като резултат.

**Задача 5** Да се създаде програма, която работи със следните команди: `double`, `add one`, `print`, `exit`. Първоначално програмата ще започва с предварително дефиниран масив от елементи и ще се подават команди от изброените, докато не се подаде команда `exit`, в който случай програмата трябва да приключи. Когато се подаде команда `double`, трябва всички елементи в масивът да бъдат умножени по 2. Когато се подаде команда `add one`, към всеки елемент на масива да се добави единица. И когато се подаде команда `print` да се изпринтира масивът.
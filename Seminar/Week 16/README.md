<h1>Подготовка за изпит</h1>

**Задача 1**
Студент се е регистрирал за n семинари и иска да присъства на максималния брой семинари, където няма два семинара, които да се припокриват. Трябва да направите следното:

Приложете структури:

struct Seminar със следните членове:

Начален час на семинара.
Продължителност на семинара.
Краен час на семинара.
struct Available_Seminars със следните членове:

Цяло число (броят семинари, за които студентът се е записал).
Масив от тип Seminar array с размер n.

Имплементирайте 2 функции:

1. Available_Seminars* initialize(int start_time[], int duration[], int n)
Създава обект Available_Seminars и инициализира елементите му с помощта на елементите в параметрите и (и двата са с размер n). Тук start_time[i] и duration[i] са съответните начален час и продължителност на i-тия семинар. Тази функция трябва да върне указател към обект Available_Seminars.

2. int CalculateMaxSeminars(Available_Seminars* ptr)
Връща максималния брой семинари, които ученикът може да посети – без припокриване. Следващият семинар не може да бъде посетен, докато предишният семинар не приключи.

Забележка: Масив с неизвестен размер(n) трябва да бъде деклариран, както следва:

DataType* arrayName = нов DataType[n];


***Формат на въвеждане***

На първият ред на стандартният вход се въвежда цяло положително число n. На следващите два реда се въвеждат n на брой цели положителни числа а именно елементите на start_time и duration.

***Ограничения***

- 1 <= n <= $10^5$
- 0 <= $start$_$time_i$ <= $10^3$
- 0 <= $duration_i$ <= $10^3$

***Изходен формат***

На стандартният изход да се изпринтира само едно число. Максималният брой незастъпващи се семинари, които студентът може да посети.

***Примерен вход***

6
1 3 0 5 5 8
1 1 6 2 4 1

***Примерен изход***

4

***Обяснение***

Студентът може да присъства на семинарите 0, 1, 3 и 5 без припокриване, така че CalculateMaxSeminars ни дава резултат 4.

**Задача 2**
Даден е масив от n цели числа nums и цяло число k, да се напише функция, която връща k-тия най-голям елемент в масива.
Имайте предвид, че това е k-тият най-голям елемент в сортирания ред, а не k-тият различен елемент.


***Формат на въвеждане***

На първият ред на стандартният вход се въвежда цяло положително число n. На следващият ред се въвеждат n на брой цели числа(nums).

***Ограничения***

- 1 <= n <= $10^5$
- 1 <= k <= n <= $10^5$
- $-10^4$ <= $nums_i$ <= $10^4$

***Изходен формат***

На стандартният изход да се изпринтира само едно число. k-тото по големина число в масива.

***Пример 1:***

*Вход: n = 6, nums = [3,2,1,5,6,4], k = 2*
*Изход: 5*

***Пример 2:***

*Вход: n = 9, числа = [3,2,3,1,2,4,5,5,6], k = 4*
*Изход: 4*

**Задача 3**
Дадена ви е матрица с размери N на N. Намирате се на координати (0, 0) и трябва да стигнете до (N - 1, N - 1).

От всяка клетка можете да се движите с една колона надясно или с един ред надолу. Тоест до клетка с координати (i, j), можете да стигнете от (i - 1, j) или (i, j - 1).

Допълнително са ви дадени координатите на K на брой клетки, в които може да се стигне и по диагонал (от клетка (i - 1, j - 1)).

Когато минавате през дадена клетка събирате събирате стойността, която се намира в нея. Намерете пътя, чиято сума е максимална.

***Формат на въвеждане***

На първия ред на стандартния вход ви е дадено едно цяло положително число N.
На следващите N реда са въведени по N числа на всеки - стойностите на матрицата.
На следващия ред се въвежда K.
На следващите K реда се въвеждат по две числа - координатите на клетки, до които може да се стигнем по диагонал.

***Ограничения***

- $1$ <= N <= $10^3$
- $1$ <= K <= $10^3$
- $-5*10^3$ <= Matrix[i][j] <= $5*10^3$

***Изходен формат***

На първия ред от стандартния изход се извежда едно число - сумата събрана от желания път.

***Пример 1***

*Вход:*
5
-4040 -1507 686 -3347 -3176 
2414 -1526 3088 -4446 -2291 
1827 1903 3335 1915 -3029 
-1852 -2549 -507 -2682 -1351 
2638 4208 2982 929 2044 
4
1 1
2 2
3 3
4 3

*Изход:*
11150

***Пример 2***

*Вход:*
3
1 1 1
1 1 -1
1 -1 1
1
2 2

*Изход:*
4
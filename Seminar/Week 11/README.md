<h1>Рекурсия</h1>

<h1>1. Разпределение на паметта</h1>

- Stack - статична памет. Големината не се променя ~ 2MB
- Heap - динамична памет. Големината се променя ~ RAM size
- Global variables - променливи инциализирани с 0. Големината не се променя ~ 8KB
- Initialized data & text - инициализираните променливи и нашият код. Големината се определя при стартиране на програмата.

![](https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg)

<h1>2. Какво означава това за няшият код</h1>

- Stack
    - Променливи - int, bool, char, int*...
    - Масиви - int arr[255], char str[16]...
    - Извиквания на функции - void f(), void printArray(int *array, int size)

- Heap
    - Динамично заделени блокове от памет(operator new).

<h1>3. Рекурсивни функции</h1>

- Защо имаме нужда от рекурсията?
Краткият отговор е, че това е много полезна техника за нашия арсенал, с която можем драстично да намалим кода, който пишем.
<br>
- Пример за рекурсивна функция

```c++
void f()
{
    cout << "Hello\n";
    f();
}
```

- Тази функция ще запълни Stack-а с извиквания => Stack overflow грешка.
- За тази цел ни трябва терминиращо условие(дъно на рекурсията):

```c++
void f(unsigned int n)
{
    if(n == 0) return; // Дъно на рекурсията
    cout << "Hello\n";
    f(n - 1);
}
```

<h1>4. Видове рекурсия</h1>

- Директна:

```c++
void f()
{
    f();
}
```

Функцията извиква сама себе си.

- Индиректна:

```c++
void g();

void f()
{
    g();
}

void g()
{
    f();
}
```

Функцията извиква друга функцията, която се връща в първоначалната.

- Линейна: факториел, сума на числа, степенуване<br>
![](http://www.herevego.com/wp-content/uploads/2020/08/recur.gif)
- Експоненциална/Дървовидна: редицата на фибуначи<br>
![](https://i.stack.imgur.com/ICG4L.png)

<h1>5. Рекурсия vs Итерация</h1>

|№|                 Рекурсия                  |                 Итерация                |
|-|-------------------------------------------|-----------------------------------------|
|1|Приключва, когато базовото условие е вярно.|Приключва, когато условието стане грешно.|
|2|Използва се с функции.                     |Използва се с циклични оператори.        |
|3|Изисква допълнително памет на Stack-а.     |Не изисква допълнително памет.           |
|4|Много по-малко код.                        |Много повече код.                        |

<h1>Задачи</h1>

**Задача 1** Да се направи рекурсивна функция, която намира първата главна буква в низ. Ако низът няма главна буква да се връща '\0'. (Може да използвате и pointer arithmetic)

*Вход: my name is Gosho Изход: G*
*Вход: my name is gosho Изход:*

**Задача 2** Да се направи рекурсивна функция, която принтира пирамида от числа.

*Вход: 4*
*Изход:*<br>*1*<br>*2 3*<br>*4 5 6*<br>*7 8 9 10*

**Задача 3** Да се напише рекурсивна функция, която приема масив и събира всеки две съседни числа, докато не получи 1 число.

*Вход: [1, 2, 3, 4, 5] Изход: 48*
Поянснение:<br>[1, 2, 3, 4, 5]<br>[1 + 2, 2 + 3, 3 + 4, 4 + 5] => [3, 5, 7, 9]<br>[3 + 5, 5 + 7, 7 + 9] => [8, 12, 16]<br>[8 + 12, 12 + 16] => [20, 28]<br>[20 + 28] => 48

**Задача 4** Да се напише рекурсивна функция, която принтира всички числа с 1 до n бита, които нямат последователни 1ци.

*Вход: 4 Изход: 1 2 4 5 8 9 10*

**Задача 5** Да се напише рекурсивна функция, която по подадени N и M, размерите на площад. Намерете колко най-малко плочки ще са нужни да запълнят площада, ако плочките са размери 2^n x 2^n.

*Вход: 5 6 Изход: 9*<br>![](https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-10-13-19-07-16.png)

**Задача 6** Да се напише рекурсивна функция, която намира валиден път между две точки. На функцията ще бъде подадена матрица NxN, картата по която трябва да се движим. Ако на дадена позиция има 1, това означава че не можем да минаваме през тази клетка. Движенията може да се случват само в 4те кардинални посоки(без диагоналите).

*Вход: 8*<br>*[0, 0, 1, 0, 1, 0, 0, 1]*<br>*[0, 0, 1, 0, 0, 1, 0, 1]*<br>*[0, 1, 0, 0, 0, 1, 0, 1]*<br>*[0, 1, 0, 0, 0, 1, 0, 1]*<br>*[0, 0, 0, 0, 1, 1, 0, 1]*<br>*[0, 1, 0, 1, 1, 1, 0, 1]*<br>*[0, 1, 0, 1, 0, 1, 0, 1]*<br>*[0, 1, 1, 0, 1, 1, 0, 1]*<br>
*Вход: (0, 0) - (0, 3) Изход: true*<br>*Вход: (0, 0) - (6, 4) Изход: false*

**Задача 7** Имайки NxN поле и кон поставен в горният ляв ъгъл на полето. Да се напише рекурсивна функция, която мърдайки конят по правилата на шаха, посещава всяка една клетка. Да се изпринтира поредността, в която всяка клетка е посетена.

*Вход: 8*
*Изход:*<br>*0  59  38  33  30  17   8  63*<br>*37  34  31  60   9  62  29  16*<br>*58   1  36  39  32  27  18   7*<br>*35  48  41  26  61  10  15  28*<br>*42  57   2  49  40  23   6  19*<br>*47  50  45  54  25  20  11  14*<br>*56  43  52   3  22  13  24   5*<br>*51  46  55  44  53   4  21  12*

**Задача от изпит 2021-2022**
Ясен Яворов има малък бизнес за покупка и продажба на дърва
за огрев. С камиона си той обслужва малкото село Квадратово, като разнася
дърва за жителите му. Селото се слави с изключително правилната си
архитектура: къщите в него образуват квадрат, като от всяка къща има улица
към съседите ѝ на север, юг, изток и запад (освен тези в края на селото,
разбира се). Всяка седмица Ясен получава заявки от съселяните си, които
надлежно записва в компютъра си като квадратна матрица map от цели числа с
размерност N × N (N < 128), в която клетките означават къщите, а числата
означават заявките на всяка къща. Положително число K означава, че
стопаните на къщата искат да продадат K кубика дърва, а отрицателно число
-L означава, че те искат да купят L кубика дърва. Ясен иска да планира
обиколката си като започне от къщата си на позиция (homeRow, homeColumn), да
стигне до къщата на баба си (която също му е клиент!) на позиция (grannyRow,
grannyColumn) и да се върне обратно в къщата си. Той се чуди дали има начин
да направи това като:
● по пътя изпълнява точно заявките на къщите през които минава – понеже
Ясен не иска клиентите му да се обидят и да го оценят с една звезда, той
не може да ги подмине без да изпълни заявката им и винаги иска да я
изпълни изцяло (т.е. за цялото количество);
● на връщане той не иска да минава обратно през клиенти, чиито заявки
вече е изпълнил, за да оптимизира пътя си;
● числото в къщата на Ясен означава с колко кубика дърва той товари
камиона си първоначално;
● не иска да претоварва камиона си повече от максималния му капацитет,
зададен с положителното цяло число maxVolume;
● не иска да се окаже в ситуация, в която минава през къща, която иска да
купи дърва, а той не носи достатъчно.
Помогнете на Ясен като реализирате функция foundRoute, която приема
описаните по-горе параметри и връща като резултат булева стойност, указваща
дали в селото има път, който удовлетворява изискванията на Ясен.

Упътване: използвайте рекурсия за търсене с връщане назад (backtracking)
като записвате товара на камиона на всяка стъпка.
Бонус (0,5): Функцията да извежда и намерения път.
![](https://i.ibb.co/x1YGL3s/image.png)